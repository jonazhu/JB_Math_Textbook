Traceback (most recent call last):
  File "/home/timothyproject/anaconda3/lib/python3.8/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/timothyproject/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 1112, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/home/timothyproject/anaconda3/lib/python3.8/site-packages/nbclient/util.py", line 74, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/home/timothyproject/anaconda3/lib/python3.8/site-packages/nbclient/util.py", line 53, in just_run
    return loop.run_until_complete(coro)
  File "/home/timothyproject/anaconda3/lib/python3.8/asyncio/base_events.py", line 616, in run_until_complete
    return future.result()
  File "/home/timothyproject/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 553, in async_execute
    await self.async_execute_cell(
  File "/home/timothyproject/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 857, in async_execute_cell
    self._check_raise_for_error(cell, exec_reply)
  File "/home/timothyproject/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 760, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------

# timestep determines the accuracy of the euler method of integration
timestep = 0.001
# amplitude of noise term
amp = 0.
# the time at which the simulation ends
end_time = 500

# creates a time vector from 0 to end_time, seperated by a timestep
t = npy.arange(0,end_time,timestep)

# intialize rabbits (x) and foxes (y) vectors
x = []
y = []

"""" parameters"""

K=.05
r = .5
a=5
h=3
e=.5
m=.1

""" euler integration """

# initial conditions for the rabbit (x) and fox (y) populations at time=0
x0=.2
y0=.2
x.append(x0)
y.append(y0) 

# forward euler method of integration
# a perturbbation term is added to the differentials to make the simulation stochastic
for index in range(1,len(t)):
    
    # evaluate the current differentials
    xd = r*x[index-1]*(1-x[index-1]/K) - a * x[index-1]*y[index-1]/(1+a*h*x[index-1])
    yd = e*a*x[index-1]*y[index-1]/(1+a*h*x[index-1])-m*y[index-1]
    
    # evaluate the next value of x and y using differentials
    next_x = x[index-1] + xd * timestep
    next_y = y[index-1] + yd * timestep
    
    x.append(next_x)
    y.append(next_y)

""" visualization """

if amp == 0:    
    # visualization of deterministic populations against time
    plt.figure(figsize=(2,1))
    plt.plot(x, y)
    plt.text(x0,y0,'o',ha='center', va='center',color='r')
    plt.text(x0,y0,' Initial Point',ha='left', va='center',color='r')
    plt.ylabel('Predator Density')
    plt.xlabel('Prey Density')
    plt.title('Predator-Prey K='+str(K))
    plt.show()
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
[0;32m<ipython-input-2-5a02ad2dcd19>[0m in [0;36m<module>[0;34m[0m
[1;32m      7[0m [0;34m[0m[0m
[1;32m      8[0m [0;31m# creates a time vector from 0 to end_time, seperated by a timestep[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[0;32m----> 9[0;31m [0mt[0m [0;34m=[0m [0mnpy[0m[0;34m.[0m[0marange[0m[0;34m([0m[0;36m0[0m[0;34m,[0m[0mend_time[0m[0;34m,[0m[0mtimestep[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     10[0m [0;34m[0m[0m
[1;32m     11[0m [0;31m# intialize rabbits (x) and foxes (y) vectors[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m

[0;31mNameError[0m: name 'npy' is not defined
NameError: name 'npy' is not defined

